function [] = HawkPR( InputPath_report, InputPath_mobility, InputPath_demography, Delta, Alpha, Beta, EMitr, DaysPred, SimTimes, OutputPath_mdl, OutputPath_pred)
warning('off')

%% Read in parameter
EMitr = EMitr;
if strcmp(Alpha,'') && strcmp(Beta,'')
	disp('No shape and scale parameter for Weibull distribution provided. Use MLE to infer alpha and beta ... ')
    alphaScale_in = 0;
    betaShape_in  = 0;
else
	alphaScale_in = Alpha;
	betaShape_in  = Beta;
end 

if strcmp(Delta,'') 
        disp('No shift parameter for mobility provided.  It will set to zero ... ')
	mobiShift_in = 0;
else
	mobiShift_in = Delta;
end

% Read-in COVID data
NYT = readtable(InputPath_report,'ReadVariableNames',true);

% Read-in mobility
Mobi = readtable( InputPath_mobility,'ReadVariableNames',true);

% Read-in demographic
Demo = readtable(InputPath_demography,'ReadVariableNames',true);
Demo_val = table2array( Demo(:,4:end));

% Data pre-processing
covid = table2array( NYT(:,4:end));

% Pad to shift 
mob_head = Mobi(:,1:4);
mob_val = table2array(Mobi(:,5:end));

for pad = 1:mobiShift_in
    mob_val = [ mean(mob_val(:,1:7),2) mob_val ];
end

% Get Key and Date

NYT_Date_list = NYT.Properties.VariableNames(4:end);
NYT_Key_list = table2cell(NYT(:,1:3));

Mobi_Type_list = table2cell(Mobi(1:6,4));
Mobi_Date_list = Mobi.Properties.VariableNames(5:end);
Mobi_Key_list = table2cell(Mobi(1:6:end,1:3));

Demo_Type_list = Demo.Properties.VariableNames(4:end);
Demo_Key_list  = table2cell(Demo(:,1));

% Get number of counties and number of days
[n_cty, n_day]=size(covid);
n_mobitype = size(mob_val,1)/n_cty;

disp(['There ' num2str(n_cty) ' counties, ' num2str(n_mobitype) ' types of Mobility indices, and ' num2str(n_day) ' days in the convid reports.' ])

% Train & Test Split
n_tr = size(covid,2);
mob_tr = mob_val(:, 1:n_tr);
mob_te = mob_val(:, n_tr+1:n_tr+DaysPred);


% Normalization
mob_tr_reshape = reshape(mob_tr, n_mobitype, size(mob_tr,1)/n_mobitype * size(mob_tr,2) ).';
mob_te_reshape = reshape(mob_te, n_mobitype, size(mob_te,1)/n_mobitype * size(mob_te,2) ).';
%
Demo_val_in = Demo_val;
Demo_val_tr = repmat(Demo_val_in, n_tr,1);
Demo_val_te = repmat(Demo_val_in, DaysPred,1);

covid_tr = covid;
%
Covar_tr = [mob_tr_reshape Demo_val_tr];
Covar_te = [mob_te_reshape Demo_val_te];
%
Covar_tr_mean = mean(Covar_tr,1);
Covar_tr_std = std(Covar_tr,1);
%
Covar_tr = (Covar_tr-Covar_tr_mean) ./ Covar_tr_std;
Covar_te = (Covar_te-Covar_tr_mean) ./ Covar_tr_std;
%

% Get Variable names
VarNamesOld = [ Mobi_Type_list; Demo_Type_list.'; {['Qprob']}];
VarNames=[];
% Rename
for i = 1:size(VarNamesOld,1)
    newStr = replace( VarNamesOld{i} , ' & ' , '_' );
    newStr = replace( newStr , ' ' , '_' );
    newStr = regexprep(newStr, '^_', '');
    VarNames=[VarNames; {newStr}];
end


%% Define Parameters
n_day_tr = n_day;
T = n_day_tr;
% Boundary correction, the number of days before the total number of days (n_day)
dry_correct = 5;

% EM step iterations
emiter = EMitr; %Nt=covid(:,2:end);
break_diff = 10^-4;
% Boundary correction: T-dry_correct
% Mobility has only 6 weeks so we take the less by min(T-dry_correct, size(mobi_in,2) )
day_for_tr = min(T-dry_correct, size(mob_tr,2) );

%% Initialize Inferred Parameters

if (alphaScale_in==0) && (betaShape_in==0)
    % Weibull Distribution (scale, shape) parameters as (alphas, betas)
    alpha  = 2;
    beta = 2;
else
    alpha  = alphaScale_in;
    beta = betaShape_in;
end
% K0 reproduction number, a fuction of time and mobility.
% Estimat for each county at each day.
K0 = 1*ones(n_cty, n_day_tr);

% p is the n_day by n_day matrix.
% p( i, j), i > j stands the probability of ONE SIGLE event at day i triggered by ALL events at day j
% i.e., Prob for (j_1, j_2, ...) triggered by each i
p=[];
for i = 1:n_cty
    p{i} = zeros(n_day_tr,n_day_tr);
end

% q is the n_day by n_day matrix.
% q( i, j), i > j stands the probability of ONE SIGLE event at day i triggered by ONE SIGLE event at day j
% i.e., Prob for each j triggered by each i
q=[];
for i = 1:n_cty
    q{i} = zeros(n_day_tr,n_day_tr);
end

% Mu is the back ground rate
mus=0.5*ones(n_cty,1);

% lam is the event intensity
lam = zeros(n_cty,T);

%% EM interation
alpha_delta = []; alpha_prev = [];
beta_delta = [];  beta_prev = [];
mus_delta = [];   mus_prev = [];
K0_delta = [];    K0_prev = [];
theta_delta = []; theta_prev = [];
for itr = 1:emiter
    tic
    %% E-step
    % county levelitr
    for c = 1:n_cty
        if( sum(covid_tr(c,:)) ~= 0)
            [p{c}, q{c}, lam(c,:)] = updatep( covid_tr(c,:) , p{c}, q{c}, K0(c,:), alpha, beta, mus(c) );
        end
    end
    
    %% M-step
    % Calculate Q, which stands for the average number (observed) of children generated by a SINGLE event j
    % Note taht the last "dry_correct" days of Q will be accurate
    % Since we haven't observed their children yet
    Q = [];
    for c = 1:n_cty
        Qprob = q{c} - diag(diag(q{c}));
        
        % Note that q is prob for one event to one event
        % The average number (observed) of children generated by j would be q(i,j)*t(i)
        n_i = covid_tr(c,:).';
        Q = [Q; sum( Qprob.* n_i, 1)];
        
    end
    
    
    %% Estimate K0 and Coefficients in Possion regression
    
    % parameters for possion regression
    opts = statset('glmfit');
    opts.MaxIter = 300;
    
    % boundaty correct
    glm_tr = Covar_tr(1: n_cty*day_for_tr ,:);
    glm_y = Q(:, 1:day_for_tr);
    glm_y = reshape(glm_y, prod(size(glm_y)), 1);
    
    % weight for observation, which is the number of evets at day j
    freqs = covid_tr(:, 1:day_for_tr);
    freqs = reshape(freqs, prod(size(freqs)), 1);
    
    mdl = fitglm( glm_tr, glm_y,'linear', 'Distribution', 'poisson', 'options', opts, 'VarNames', VarNames, 'Weights', freqs);
    
    %% Estimate K0
    %mdl = fitglm( Covar_tr(1: n_cty*day_for_tr ,6:7), glm_y,'linear', 'Distribution', 'poisson', 'options', opts, 'Weights', freqs);
    [ypred,yci] = predict(mdl,Covar_tr);
    K0 = reshape(ypred, n_cty, n_day_tr);

    %Bound K0
    K0 = smoothdata(K0, 2);
    %
    %% Estimate mu, the background rate
    
    for c = 1:n_cty
        mus(c) = sum(( diag(p{c}).' .* covid_tr(c,:) )) / (n_day_tr) ;
    end
    
    %% Take all the average
    %%mus = repmat( mean(mus), size(mus, 1), size(mus, 2) );
    
    %% Estimate alpha and beta in Weibull Distribution
    
    % Get all pairs
    combos = sortrows( nchoosek( (1:n_day_tr),2 ),2);
    
    % Get those within boundary
    combos = combos(find( prod(combos<=day_for_tr,2)),: );
    combos = combos(:,end:-1:1);
    
    % allocate memory first for spead-up
    obs_sample = zeros( size(combos,1)*n_cty ,1 );
    freq_sample = zeros( size(combos,1)*n_cty ,1 );
    
    for c = 1:n_cty
        
        nc = covid_tr(c,:);
        
        % obs vation is i-j
        obs =[combos(:,1) - combos(:,2)];
        
        % freq
        Prob = p{c};
        freq = Prob(  sub2ind(size(Prob), combos(:,1), combos(:,2) ) ) .* nc(combos(:,1)).';
        if(sum(isnan(freq))>0)
            disp(sum(isnan(freq)))
        end
        % Record obs, freq
        obs_sample( (c-1)*size(combos,1)+1:c*size(combos,1) ) = obs;
        freq_sample( (c-1)*size(combos,1)+1:c*size(combos,1) ) = freq;
        
    end
    
    if (alphaScale_in==0) && (betaShape_in==0)
        % Fit weibull
        [coef,~] = wblfit(obs_sample,[],[],freq_sample);
        alpha=coef(1); % scale
        beta=coef(2);  % shape
        if beta > 100
            beta = 100;
        end
        if alpha > 100
            alpha = 100;
        end
    else
        alpha  = alphaScale_in;
        beta = betaShape_in;
    end
    
    
    
    %% check for the convergence
    if(itr==1)
        % save the first value
        alpha_prev = alpha; beta_prev = beta; mus_prev = mus; K0_prev = K0; theta_prev = mdl.Coefficients.Estimate;
    else
        % Calculate the RMSR
        alpha_delta = [alpha_delta sqrt( (alpha-alpha_prev).^2 )];
        beta_delta  = [beta_delta  sqrt( (beta-beta_prev).^2 )];
        mus_delta   = [mus_delta sqrt( sum((mus_prev - mus).^2)/numel(mus) )];
        K0_delta    = [K0_delta sqrt( sum(sum((K0_prev - K0).^2))/numel(K0) )];
        theta_delta   = [theta_delta sqrt( sum((theta_prev - mdl.Coefficients.Estimate).^2)/numel(mdl.Coefficients.Estimate) )];
        % save the current
        alpha_prev = alpha; beta_prev = beta; mus_prev = mus; K0_prev = K0; theta_prev = mdl.Coefficients.Estimate;
    end
    %disp(max(K0(:)))
    [wblstat_M, wblstat_V]=wblstat(alpha, beta);
     %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %%

    %%%%%%%%%%%%%%%%%%
    % Early Stop
    %%%%%%%%%%%%%%%%%%

    if (itr > 5)
        rule = all( alpha_delta(end-4:end) < break_diff) & all( beta_delta(end-4:end) < break_diff);
        rule = rule &  all( mus_delta(end-4:end) < break_diff) & all( K0_delta(end-4:end) < break_diff);
        rule = rule &  all( theta_delta(end-4:end) < break_diff);

        if( rule )
            disp(['Convergence Criterion Meet. Break out EM iteration ...'])
            break;
        end
    end
    t = toc;
    disp(['Iterattion ' num2str(itr) ', Elapse time: ' num2str(t)])
end
if(itr == emiter)
    disp(['Reach maximun EM iteration.'])
end
save(OutputPath_mdl,'mus','alpha','beta','K0','mdl','VarNames','alpha_delta','beta_delta','mus_delta','K0_delta','theta_delta')

% Start Simulation
load(OutputPath_mdl, 'mus','alpha','beta','K0','mdl','VarNames','alpha_delta','beta_delta','mus_delta','K0_delta','theta_delta')

%% Get K0
Covar_all = [Covar_tr; Covar_te];
n_day = n_day_tr+DaysPred;
T_sim = n_day;
%% Predict
[ypred,yci] = predict(mdl,Covar_all);
fK0 = reshape(ypred, n_cty, n_day);

% Simulation results
sim = zeros(n_cty, T_sim, SimTimes);

% Loop for simulation
for c = 1:n_cty
    tic
    tr_in = covid_tr(c,:);
    for itr = 1:SimTimes
        rng(itr);
        [times_sim] = Hawkes_Sim_Corona( mus(c), alpha, beta, T_sim, fK0(c,:), T_sim-DaysPred, itr,  tr_in);
        %
        [Nt]=discrete_hawkes(times_sim,T_sim);
        %
        sim(c,:,itr) = Nt;
    end
    t = toc;
    disp(['Simulation county ' num2str(c) ', Elapse time: ' num2str(t)])
end

% Formate the output 
sim_mean = mean(sim,3);
sim_mean = sim_mean(:, end-DaysPred+1:end);

% Get header 
Date_pred = datetime(datestr( replace(NYT_Date_list(end),'x','') ,'mm/dd/yyyy'))+days(1:DaysPred);
Date_pred = replace(string( datestr(Date_pred,'xyyyy/mm/dd')), '/' ,'_');

table_out  = array2table(sim_mean);
table_out.Properties.VariableNames = Date_pred;
table_out = [NYT(:,1:3) table_out];

writetable(table_out,OutputPath_pred)
end
